## Context

現行の共有/外部アプリ起動は、アクション発火ごとに画像URLから共有用URIを生成している。共通ランナーによってスレッド画面と画像ビューア画面で同一処理を呼び出しているため、待ち時間も両画面で同様に発生する。

画像表示自体は Coil 経由で行われるが、共有時のURI生成は表示パイプラインと連携していない。結果として、表示済み画像でもネットワーク取得とキャッシュファイル生成が再実行され、共有シート表示までの初動が遅くなる。

## Goals / Non-Goals

**Goals:**
- 表示済み画像データを共有/外部アプリ起動で再利用し、共有シート表示までの待ち時間を短縮する。
- スレッド画面と画像ビューア画面の双方で同一の再利用契約を適用する。
- 再利用不可時のフォールバック経路を維持し、機能互換を崩さない。

**Non-Goals:**
- 画像表示ライブラリそのものの置き換え。
- 画像保存機能（端末ストレージ保存）の挙動変更。
- 共有先アプリごとの挙動最適化。

## Decisions

- **共有準備は「表示データ再利用優先 + 従来フォールバック」の二段階にする**
  - まず表示成功時に得られるキャッシュ情報（例: disk cache key）から共有可能URIを復元する。
  - 復元に失敗した場合のみ、既存のURL再取得フローを実行する。
  - これにより初回表示後の再共有は高速化しつつ、未表示画像でも従来どおり動作する。

- **再利用情報は共通レジストリで管理し、画面依存を持たせない**
  - 共有ランナーが参照する再利用レジストリを導入し、URLと表示キャッシュ情報を関連付ける。
  - スレッド画面/画像ビューアのどちらから登録されても、共有ランナーは同一APIで利用する。

- **互換性維持のため外部起動と共有の処理契約は共通化を継続する**
  - `OPEN_IN_OTHER_APP` と `SHARE_IMAGE` の再利用ロジックは同じ前処理を使い、分岐はIntent組み立てのみとする。

## Risks / Trade-offs

- [Risk] 表示キャッシュがメモリから破棄された後に再利用キーが不整合になる可能性。
  - Mitigation: 再利用失敗時は即座に既存フォールバックへ切り替え、エラーをユーザーへ露出しない。

- [Risk] 再利用レジストリが増え続けるとメモリ負荷が増える可能性。
  - Mitigation: URL単位で上書きし、最大保持件数またはTTLで自動削除する。

- [Trade-off] 実装複雑性は増えるが、共有/外部起動の体感改善とネットワーク再取得削減の効果が見込める。
