## 背景
ブックマーク編集の処理が複数のViewModelに分散しており、同等のロジックが重複している。シート表示時のみ必要な処理はViewModelではなく軽量なステートホルダーにまとめる。

## 目標 / 非目標
- 目標:
  - シート専用の状態と処理を一箇所に集約する
  - 単体/一括の区別は持たず、targetsのリストで同一処理として扱う
  - 板とスレの混在選択は許可しない
  - 画面側ViewModelから依存を渡して生成・破棄する方式に統一する
  - 星表示などの常駐状態は画面ViewModel側で購読する
- 非目標:
  - ブックマークUI/UXの再設計
  - Repository APIやDBスキーマの変更

## 決定事項
- 決定: ViewModelではなく `BookmarkBottomSheetStateHolder`（仮名）を導入し、targetsのリストに対する同一処理で統一する。
  - 理由: 単体/一括の分岐を減らし、処理を一本化できるため。
  - 理由: 板とスレの混在を型で排除し、処理の分岐を最小化するため。
- 決定: 依存は画面側ViewModelから渡してステートホルダーを生成し、開閉状態もステートホルダーが保持する。
  - 理由: UI側はopen/closeの委譲のみで済み、画面ViewModelの責務を最小化できるため。
- 決定: シートの操作（適用/解除/編集）はUIがステートホルダーを直接呼び出す。
  - 理由: ViewModelにシート操作のAPIを残さず、薄い画面ロジックに寄せるため。
- 決定: ステートホルダーの操作は内部スコープで実行し、UIはコルーチンを持たない。
  - 理由: 画面側に非suspend APIを提供し、呼び出し側の責務を減らすため。
- 決定: ツールバーの星表示など常駐が必要な状態は画面ViewModelで購読して保持する。
  - 理由: シート非表示中でもブックマーク状態を更新し続ける必要があるため。

## 代替案
- `hiltViewModel()` でシート用ViewModelを作る
  - 却下: 画面に紐づき短命にならず、シート表示時だけの生成/破棄にならない。
- 既存 `SingleBookmarkViewModel` を残してラップする
  - 却下: 重複ロジックが残る。

## リスク / トレードオフ
- シート用ステートホルダーが短命になるため、回転等で入力状態が消える可能性がある。
  - 対策: 必要なら画面側ViewModelで一時値を保持する。

## 移行手順
1. ステートホルダーと `UiState` を追加する。
2. 画面ViewModelが依存を渡してステートホルダーを生成する流れに置き換える。
3. `ThreadViewModel` / `BoardViewModel` / `BookmarkListViewModel` のブックマーク処理を委譲に切り替える。
4. 旧 `SingleBookmarkViewModel` を削除する。

## 未決事項
- なし
