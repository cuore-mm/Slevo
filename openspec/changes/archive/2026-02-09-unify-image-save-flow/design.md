## Context

現在、スレッド画面と画像ビューア画面は画像保存機能をそれぞれ独立実装しており、URL正規化・権限要求・保留URL管理・保存結果通知のロジックが重複している。実装の重複により、片側のみ修正される差分や保存結果通知の不一致が発生しやすい。

対象機能は `ImageMenuActionRunner` から単体保存/一括保存を呼び出す経路であり、両画面で保存依頼のインターフェースを揃えれば保存フロー自体は統合できる。UI層には Android の `ActivityResultContracts.RequestPermission` が残るが、保存ロジックの責務は ViewModel/共通コンポーネントへ寄せられる。

## Goals / Non-Goals

**Goals:**
- 保存権限要求フローと保存結果トースト文言を、スレッド画面と画像ビューア画面で完全に一致させる。
- 画像保存ロジック（正規化、保留URL、保存実行、結果メッセージ生成）を共通化し、片側改修漏れを防ぐ。
- 画面側の責務を「権限ランチャー起動」と「UIイベント表示」に限定する。

**Non-Goals:**
- 画像コピー/共有/外部アプリ起動など、保存以外の画像アクション仕様変更。
- 保存先や保存アルゴリズム（MediaStore 操作）の仕様変更。
- メニュー UI デザインや配置変更。

## Decisions

- Decision 1: 保存フローを共通コーディネータとして抽出し、両画面 ViewModel から同一契約で利用する。
  - 採用理由: 権限前後の分岐とトースト文言を1か所に集約できる。
  - 代替案: 各画面に同一ロジックを複製して維持。却下理由は保守コスト増と再発リスク。

- Decision 2: pending URL の保持先を ViewModel に統一する。
  - 採用理由: 画面再構成時でも保存再試行状態を一貫管理でき、Viewer/Thread の責務差をなくせる。
  - 代替案: Viewer は Composable ローカル状態を継続。却下理由は責務不一致の温存。

- Decision 3: UI には権限要求トリガーのみ残し、権限結果を ViewModel に返すイベント駆動にする。
  - 採用理由: Android API 依存を UI 層に閉じ込めつつ、保存フロー本体をテスト可能にできる。
  - 代替案: ViewModel から直接権限要求。却下理由はプラットフォーム API 制約で実装が不自然。

- Decision 4: 保存結果トースト文言は共通フォーマッタ（単体成功/単体失敗/全成功/全失敗/部分成功）を使用する。
  - 採用理由: 既存仕様を保ったまま画面差を排除できる。
  - 代替案: 画面個別で文言分岐。却下理由は仕様ドリフトを招く。

## Risks / Trade-offs

- [Risk] 既存の ViewModel public API 変更により呼び出し箇所が広く影響する。
  → Mitigation: 先に共通コーディネータを追加し、既存関数を段階的に置換する。

- [Risk] 権限拒否時の UX が画面ごとに微妙に異なる既存挙動を失う可能性。
  → Mitigation: 現行トースト文言と発火タイミングを仕様として明文化し、差分テストで確認する。

- [Risk] pending URL 管理の移行時に再試行経路が壊れる。
  → Mitigation: 権限未付与→許可のシナリオを Viewer/Thread の双方で検証する。
